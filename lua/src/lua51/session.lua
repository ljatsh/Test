
--- session

local luv = require('luv')
local class = require('class')
local stream_socket = require('stream_socket')

local session = class()

--- session status
-- @table status
local status = {
  closed = 1,               -- closed
  connecting = 2,           -- connecting
  connected = 3,            -- connected (authentication logic must be done during this period)
  authenticating = 4,       -- authenticating
  authenticated = 5,        -- authenticated
}

session.status = status

--- player send data transparently on session and will be notified by arrived messages
-- @param host the remote host address
-- @param port the remote host port
-- @param parser process incoming data
-- @param sink session status event sink
function session:ctor(host, port, parser, sink)
  self.socket = stream_socket.new(host, port)
  self.parser = parser
  self.sink = sink
  self.send_head = nil
  self.send_tail = nil
  self.stop = false
  self.status = status.closed
end

--- start a new thread to drive the work flow
-- @return true | false
-- @return error
function session:start()
  if self.status ~= status.closed then
    return false, 'session is active'
  end

  self.main_thread = luv.fiber.create(function()
    local s, err = self.socket:connect()

    if s == nil then
      if self.sink ~= nil then
        self.sink:on_session_connecting_failure(self, err)
      end
      return
    end

    if self.sink ~= nil then
      self.sink:on_session_connected(self)

      local ret, err = self.sink:on_session_authentication(self)
      if not ret then
        print('authentication error: ', err)
        self.socket:close()
        return
      end

      self.status = status.authenticated

      self:_start_write_thread()
    end
  end)
  
  self.main_thread:ready()

  return true
end

--- force stopping the session work flow synchronously
-- @return true | false
-- @return error
function session:stop()
  self.main_thread:join()
end

--- send msg asynchronously in sequence order
-- push msg to the back of sending queue
-- @param msg
function session:send(data)
  if self.send_head == nil then
    self.send_head = {data = data, next = nil}
    self.send_tail = self.send_head

    self.write_cond:signal()
    return
  end

  self.send_tail.next = {data = data, next = nil}
  self.send_tail = self.send_tail.next
end

--- this event was triggered when a new message was generated by the working parser
function session:on_message(msg)
end

--- wirte data to the underline socket
-- this API blocks current thread. Game developer should not use this API directly
-- @return true | false, err
function session:_write(data)
end

--- pump next avaiable message from session
-- this API blocks current thread. Game developer should not use this API directly
-- @return message | nil, err
function session:_pump_next_message()
end

function session:_start_write_thread()
  assert (self.write_thread == nil)

  self.write_cond = luv.cond.create()
  local ret = true
  local err

  self.write_thread = luv.fiber.create(function()
    repeat
      while self.send_head ~= nil do
        local data = self.send_head.data

        ret, err = self.socket:write(data)
        if not ret then
          break
        end

        self.send_head = self.send_head.next
      end

      -- exit thread if error occurred
      if not ret then
        print('session write error: ', err)
        break
      end

      self.send_tail = nil

      self.write_cond:wait()

    until self.stop
  end)

  self.write_thread:ready()
end

return session
