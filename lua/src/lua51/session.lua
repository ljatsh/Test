
--- session

local luv = require('luv')
local class = require('class')
local stream_socket = require('stream_socket')

local session = class()

--- session status
-- @table status
local status = {
  closed = 1,               -- closed
  connecting = 2,           -- connecting
  connected = 3,            -- connected (authentication logic must be done during this period)
  authenticating = 4,       -- authenticating
  authenticated = 5,        -- authenticated
}

session.status = status

--- player send data transparently on session and will be notified by arrived messages
-- @param host the remote host address
-- @param port the remote host port
-- @param parser process incoming data
-- @param sink session status event sink
function session:ctor(host, port, parser, sink)
  self.socket = stream_socket.new(host, port)
  self.parser = parser
  self.sink = sink
  self.status = status.closed
end

--- start a new thread to drive the work flow
-- @return true | false
-- @return error
function session:start()
  self.main_thread = luv.fiber.create(function()
    local s, err = self.socket:connect()

    print(s, err)
    print(self.socket:write('1234'))
  end)
  
  self.main_thread:ready()

  return true
end

--- force stopping the session work flow synchronously
-- @return true | false
-- @return error
function session:stop()
  self.main_thread:join()
end

--- send msg asynchronously in sequence order
-- push msg to the back of sending queue
-- @param msg
function session:send(data)
end

--- this event was triggered when a new message was generated by the working parser
function session:on_message(msg)
end

--- wirte data to the underline socket
-- this API blocks current thread. Game developer should not use this API directly
-- @return true | false, err
function session:_write(data)
end

--- pump next avaiable message from session
-- this API blocks current thread. Game developer should not use this API directly
-- @return message | nil, err
function session:_pump_next_message()
end

return session
